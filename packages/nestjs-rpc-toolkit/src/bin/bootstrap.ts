#!/usr/bin/env node

import * as path from 'path';
import * as fs from 'fs';
import * as readline from 'readline';

interface InitConfig {
  packagePath: string;
  packageName: string;
  modulePackages: string[];
}

class RpcPackageInitializer {
  private cwd: string;
  private rl: readline.Interface;

  constructor() {
    this.cwd = process.cwd();
    this.rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
  }

  async bootstrap(): Promise<void> {
    console.log('üöÄ NestJS RPC Package Initializer\n');

    const config = await this.promptForConfig();
    await this.createRpcPackage(config);

    this.rl.close();

    console.log('\n‚úÖ RPC package initialized successfully!');
    console.log('\nNext steps:');
    console.log('1. Update module packages in nestjs-rpc-toolkit.config.json (supports wildcards like "packages/modules/*")');
    console.log('2. Run "npm run generate:types" to generate RPC types');
    console.log('3. Build the package with "npm run build"');
  }

  private async promptForConfig(): Promise<InitConfig> {
    const packagePath = await this.question(
      'Where would you like to create the RPC package? ',
      'packages/lib-rpc'
    );

    const projectName = path.basename(this.cwd);
    const defaultPackageName = `@${projectName}/rpc`;
    const packageName = await this.question(
      'What should the package name be? ',
      defaultPackageName
    );

    const modulePackagesInput = await this.question(
      'Enter module packages to scan for RPC methods (comma-separated, supports wildcards): ',
      'packages/modules/*'
    );

    const modulePackages = modulePackagesInput
      .split(',')
      .map(p => p.trim())
      .filter(p => p.length > 0);

    return {
      packagePath: packagePath.trim(),
      packageName: packageName.trim(),
      modulePackages
    };
  }

  private async question(prompt: string, defaultValue?: string): Promise<string> {
    const displayPrompt = defaultValue ? `${prompt}(${defaultValue}) ` : prompt;

    return new Promise((resolve) => {
      this.rl.question(displayPrompt, (answer) => {
        resolve(answer.trim() || defaultValue || '');
      });
    });
  }

  private async createRpcPackage(config: InitConfig): Promise<void> {
    const fullPackagePath = path.resolve(this.cwd, config.packagePath);

    // Create directory structure
    await this.ensureDirectory(fullPackagePath);
    await this.ensureDirectory(path.join(fullPackagePath, 'src'));
    await this.ensureDirectory(path.join(fullPackagePath, 'scripts'));

    // Create files
    await this.createPackageJson(fullPackagePath, config);
    await this.createTsConfig(fullPackagePath);
    await this.createRpcConfig(fullPackagePath, config);
    await this.createGenerateScript(fullPackagePath);
    await this.createSourceFiles(fullPackagePath);

    console.log(`üì¶ Created RPC package at: ${config.packagePath}`);
  }

  private async ensureDirectory(dirPath: string): Promise<void> {
    if (!fs.existsSync(dirPath)) {
      fs.mkdirSync(dirPath, { recursive: true });
    }
  }

  private async createPackageJson(packagePath: string, config: InitConfig): Promise<void> {
    const packageJson = {
      name: config.packageName,
      version: "1.0.0",
      description: "Package containing shared types for RPC calls in this monorepo (generated by @zdavison/nestjs-rpc-toolkit)",
      main: "dist/index.js",
      types: "dist/index.d.ts",
      scripts: {
        build: "npm run generate:types && tsc",
        clean: "rm -rf dist",
        dev: "tsc --watch",
        "generate:types": "ts-node scripts/generate-all-rpc-types.ts"
      },
      dependencies: {
        "@zdavison/nestjs-rpc-toolkit": "^0.0.12",
        "@nestjs/common": "^10.0.0",
        "@nestjs/microservices": "^10.0.0"
      },
      devDependencies: {
        "@types/node": "^24.5.1",
        typescript: "^5.0.0",
        "ts-node": "^10.9.0",
        "ts-morph": "^20.0.0"
      }
    };

    const filePath = path.join(packagePath, 'package.json');
    fs.writeFileSync(filePath, JSON.stringify(packageJson, null, 2));
  }

  private findRootTsConfig(): string | null {
    // Search for root tsconfig files starting from repo root
    const possiblePaths = [
      'tsconfig.base.json',
      'tsconfig.json'
    ];

    // Find git root or use current working directory
    let searchDir = this.cwd;
    try {
      // Try to find git root by looking for .git directory
      let current = this.cwd;
      while (current !== path.dirname(current)) {
        if (fs.existsSync(path.join(current, '.git'))) {
          searchDir = current;
          break;
        }
        current = path.dirname(current);
      }
    } catch {
      // If git root search fails, use current directory
    }

    for (const tsConfigPath of possiblePaths) {
      const fullPath = path.join(searchDir, tsConfigPath);
      if (fs.existsSync(fullPath)) {
        return fullPath;
      }
    }

    return null;
  }

  private async createTsConfig(packagePath: string): Promise<void> {
    // Try to find a root tsconfig to extend from
    const rootTsConfig = this.findRootTsConfig();

    let tsConfig: any;

    if (rootTsConfig) {
      // Calculate relative path from package to root tsconfig
      const relativePath = path.relative(packagePath, rootTsConfig);

      tsConfig = {
        extends: relativePath,
        compilerOptions: {
          outDir: "./dist",
          declaration: true,
          declarationMap: true,
          sourceMap: true
        },
        include: ["src/**/*"],
        exclude: ["node_modules", "dist", "**/*.spec.ts", "**/*.test.ts"]
      };
    } else {
      // Create a standalone valid tsconfig
      tsConfig = {
        compilerOptions: {
          target: "ES2020",
          module: "commonjs",
          lib: ["ES2020"],
          outDir: "./dist",
          rootDir: "./src",
          strict: true,
          esModuleInterop: true,
          skipLibCheck: true,
          forceConsistentCasingInFileNames: true,
          declaration: true,
          declarationMap: true,
          sourceMap: true,
          experimentalDecorators: true,
          emitDecoratorMetadata: true
        },
        include: ["src/**/*"],
        exclude: ["node_modules", "dist", "**/*.spec.ts", "**/*.test.ts"]
      };
    }

    const filePath = path.join(packagePath, 'tsconfig.json');
    fs.writeFileSync(filePath, JSON.stringify(tsConfig, null, 2));
  }

  private async createRpcConfig(packagePath: string, config: InitConfig): Promise<void> {
    const rpcConfig = {
      packages: config.modulePackages,
      outputDir: path.join(config.packagePath, 'src')
    };

    const filePath = path.join(packagePath, 'nestjs-rpc-toolkit.config.json');
    fs.writeFileSync(filePath, JSON.stringify(rpcConfig, null, 2));
  }

  private async createGenerateScript(packagePath: string): Promise<void> {
    const script = `import { RpcTypesGenerator } from '@zdavison/nestjs-rpc-toolkit';
import * as path from 'path';

// Run the generator - we're in ${path.basename(packagePath)}/scripts
const rootDir = path.join(__dirname, '../../../');
const configPath = path.join(__dirname, '../nestjs-rpc-toolkit.config.json');

const generator = new RpcTypesGenerator({
  rootDir,
  configPath,
});

generator.generate();
`;

    const filePath = path.join(packagePath, 'scripts', 'generate-all-rpc-types.ts');
    fs.writeFileSync(filePath, script);
  }

  private async createSourceFiles(packagePath: string): Promise<void> {
    // Create index.ts
    const indexContent = `export * from './all.rpc.gen';
export * from './typed-message-bus';
`;
    fs.writeFileSync(path.join(packagePath, 'src', 'index.ts'), indexContent);

    // Create typed-message-bus.ts
    const messageBusContent = `import { MessageBus as BaseMessageBus, IMessageBus } from '@zdavison/nestjs-rpc-toolkit';
import { AllRpcMethods } from './all.rpc.gen';
import { Injectable } from '@nestjs/common';
import { ClientProxy } from '@nestjs/microservices';

// Typed version of MessageBus with generated types
export interface ITypedMessageBus extends IMessageBus<AllRpcMethods> {}

@Injectable()
export class MessageBus extends BaseMessageBus<AllRpcMethods> implements ITypedMessageBus {
  constructor(client: ClientProxy) {
    super(client);
  }
}
`;
    fs.writeFileSync(path.join(packagePath, 'src', 'typed-message-bus.ts'), messageBusContent);

    // Create placeholder all.rpc.gen.ts
    const placeholderContent = `// This file will be generated by the RPC types generator
// Run 'npm run generate:types' to generate the actual types

export interface AllRpcMethods {
  // Generated RPC method types will appear here
}
`;
    fs.writeFileSync(path.join(packagePath, 'src', 'all.rpc.gen.ts'), placeholderContent);
  }
}

// Main execution
if (require.main === module) {
  const initializer = new RpcPackageInitializer();
  initializer.bootstrap().catch((error) => {
    console.error('‚ùå Error initializing RPC package:', error);
    process.exit(1);
  });
}

export { RpcPackageInitializer };