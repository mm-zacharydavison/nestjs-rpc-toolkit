import { Injectable } from '@nestjs/common';
import { ClientProxy } from '@nestjs/microservices';
import { firstValueFrom } from 'rxjs';
import { RpcCodecRegistry, RpcCodecMetadata, dateCodec } from '../codecs';
import { InProcessClientProxy } from '../transport/in-process.client';

/**
 * Function info for an RPC pattern, containing param and return type mappings.
 */
export interface RpcPatternFunctionInfo {
  /** Maps parameter names to their type names */
  params: Record<string, string>;
  /** The return type name, or undefined if no codec fields */
  returns: string | undefined;
}

/**
 * Maps RPC patterns to their function info.
 * Generated by the RPC type generator (RpcFunctionInfo).
 */
export type RpcFunctionInfoMap = Record<string, RpcPatternFunctionInfo>;

/**
 * Options for creating an RPC client with automatic type transformations.
 */
export interface RpcClientOptions {
  /**
   * Type metadata mapping type names to their codec fields.
   * Generated by the RPC type generator (RpcTypeInfo).
   */
  typeInfo?: RpcCodecMetadata;

  /**
   * Function info mapping RPC patterns to their param/return type names.
   * Generated by the RPC type generator (RpcFunctionInfo).
   */
  functionInfo?: RpcFunctionInfoMap;
}

/**
 * Check if codec transformation should be skipped.
 * Skips for in-process clients unless NRPCTK_STRICT env var is truthy.
 */
function shouldSkipCodec(client: ClientProxy): boolean {
  if (process.env.NRPCTK_STRICT) {
    return false;
  }
  return client instanceof InProcessClientProxy;
}

@Injectable()
export class RpcClient {
  private codecRegistry: RpcCodecRegistry;
  private typeInfo: RpcCodecMetadata;
  private functionInfo: RpcFunctionInfoMap;
  private skipCodec: boolean;

  constructor(
    private readonly client: ClientProxy,
    options: RpcClientOptions = {},
  ) {
    // Use built-in codecs (Date)
    this.codecRegistry = new RpcCodecRegistry([dateCodec]);
    this.typeInfo = options.typeInfo ?? {};
    this.functionInfo = options.functionInfo ?? {};
    this.skipCodec = shouldSkipCodec(client);
  }

  /**
   * Create domain proxies dynamically based on the RPC methods available.
   * Automatically encodes/decodes values using registered codecs.
   * Skips codec transformation for in-process clients (unless NRPCTK_STRICT is set).
   */
  createDomainProxy(domain: string): any {
    return new Proxy({}, {
      get: (_target, methodName: string) => {
        return async (params: any) => {
          const pattern = `${domain}.${methodName}`;
          try {
            // Skip codec for in-process (no serialization needed)
            if (this.skipCodec) {
              const observable = this.client.send(pattern, params);
              return await firstValueFrom(observable);
            }

            // Encode params (Date -> string, etc.) - uses runtime detection
            const encodedParams = this.codecRegistry.encode(params);

            const observable = this.client.send(pattern, encodedParams);
            const result = await firstValueFrom(observable);

            // Decode result (string -> Date, etc.) based on return type info
            const patternInfo = this.functionInfo[pattern];
            const returnTypeName = patternInfo?.returns;
            return this.codecRegistry.decode(result, this.typeInfo, returnTypeName);
          } catch (error) {
            throw new Error(`RPC call to '${pattern}' failed: ${error instanceof Error ? error.message : String(error)}`);
          }
        };
      }
    });
  }
}

/**
 * Create an RPC client proxy with automatic Date transformation.
 * Use this to create the 'RPC' provider with automatic type transformations.
 *
 * Date fields are automatically:
 * - Encoded to ISO strings when sending RPC calls
 * - Decoded back to Date objects when receiving responses
 *
 * @example
 * ```typescript
 * import { RpcTypeInfo, RpcFunctionInfo } from '@your-org/lib-rpc';
 * import { createRpcClientProxy } from '@zdavison/nestjs-rpc-toolkit';
 *
 * {
 *   provide: 'RPC',
 *   useFactory: (client: ClientProxy) => createRpcClientProxy(client, {
 *     typeInfo: RpcTypeInfo,
 *     functionInfo: RpcFunctionInfo,
 *   }),
 *   inject: [IN_PROCESS_CLIENT],
 * }
 * ```
 */
export function createRpcClientProxy(
  client: ClientProxy,
  options: RpcClientOptions = {},
): any {
  const rpcClient = new RpcClient(client, options);
  return new Proxy({}, {
    get: (_target, domain: string) => {
      return rpcClient.createDomainProxy(domain);
    }
  });
}

// Base interface for the typed RPC client
export interface ITypedRpcClient {
  [domain: string]: {
    [method: string]: (params: any) => Promise<any>;
  };
}