import { Module, DynamicModule, type Type } from '@nestjs/common';
import { ClientsModule } from '@nestjs/microservices';
import type { RpcClientProxy } from '../interfaces';
import { createRpcClientProxy, type RpcFunctionInfoMap } from './rpc-client';
import type { RpcCodecMetadata } from '../codecs';
import { InProcessTransportStrategy } from '../transport/in-process.transport';
import { InProcessClientProxy } from '../transport/in-process.client';

/**
 * Options for RpcModule.forRoot()
 */
export interface RpcModuleOptions {
  /**
   * The InProcessTransportStrategy instance to use for RPC communication.
   * When provided, InProcessClientProxy will be created automatically.
   * This is the recommended approach for in-process RPC.
   *
   * @example
   * ```typescript
   * const transport = new InProcessTransportStrategy();
   * RpcModule.forRoot({ transport })
   * ```
   */
  transport?: InProcessTransportStrategy;

  /**
   * The ClientProxy class to use for RPC communication.
   * @deprecated Use `transport` instead for in-process RPC.
   */
  clientProxyClass?: Type<RpcClientProxy>;

  /**
   * Optional injection token for the client.
   * Defaults to 'RPC_CLIENT'.
   */
  clientToken?: string;

  /**
   * Type metadata mapping type names to their codec fields.
   * Generated by the RPC type generator (RpcTypeInfo).
   * When provided, Date fields are automatically converted.
   */
  typeInfo?: RpcCodecMetadata;

  /**
   * Function info mapping RPC patterns to their param/return type names.
   * Generated by the RPC type generator (RpcFunctionInfo).
   */
  functionInfo?: RpcFunctionInfoMap;
}

/**
 * Token used to inject the RPC ClientProxy.
 */
export const RPC_CLIENT = 'RPC_CLIENT';

/**
 * Token used to inject the configured RPC client proxy.
 * This provides a ready-to-use RPC client with automatic type transformations.
 */
export const RPC = 'RPC';

/**
 * Token used to inject the InProcessTransportStrategy.
 * Useful when you need to connect the transport as a microservice strategy.
 */
export const IN_PROCESS_TRANSPORT = 'IN_PROCESS_TRANSPORT';

/**
 * Module that configures RPC communication for a NestJS application.
 *
 * @example
 * ```typescript
 * import { RpcModule, InProcessTransportStrategy } from '@zdavison/nestjs-rpc-toolkit';
 * import { RpcTypeInfo, RpcFunctionInfo } from '@your-org/lib-rpc';
 *
 * // Recommended: Pass transport instance directly
 * const transport = new InProcessTransportStrategy();
 *
 * @Module({
 *   imports: [
 *     RpcModule.forRoot({
 *       transport,
 *       typeInfo: RpcTypeInfo,
 *       functionInfo: RpcFunctionInfo,
 *     }),
 *   ],
 * })
 * export class AppModule {}
 *
 * // In any module, inject 'RPC' to get the configured client:
 * @Injectable()
 * class MyService {
 *   constructor(@Inject('RPC') private rpc: IRpcClient) {}
 * }
 * ```
 */
@Module({})
export class RpcModule {
  /**
   * Configure the RPC module with a specific transport or ClientProxy implementation.
   *
   * @param options - Configuration options
   * @returns Dynamic module configuration
   */
  static forRoot(options: RpcModuleOptions): DynamicModule {
    const clientToken = options.clientToken ?? RPC_CLIENT;

    // Recommended: Use transport option for in-process RPC
    if (options.transport) {
      return {
        module: RpcModule,
        providers: [
          // Provide the transport for microservice setup
          {
            provide: IN_PROCESS_TRANSPORT,
            useValue: options.transport,
          },
          // Create InProcessClientProxy with the transport
          {
            provide: clientToken,
            useFactory: (transport: InProcessTransportStrategy) =>
              new InProcessClientProxy(transport),
            inject: [IN_PROCESS_TRANSPORT],
          },
          // Provide a configured RPC client proxy with automatic type transformations
          {
            provide: RPC,
            useFactory: (client: RpcClientProxy) =>
              createRpcClientProxy(client, {
                typeInfo: options.typeInfo,
                functionInfo: options.functionInfo,
              }),
            inject: [clientToken],
          },
        ],
        exports: [IN_PROCESS_TRANSPORT, clientToken, RPC],
        global: true,
      };
    }

    // Legacy: use clientProxyClass with ClientsModule
    if (!options.clientProxyClass) {
      throw new Error(
        'RpcModule.forRoot requires either transport or clientProxyClass',
      );
    }

    return {
      module: RpcModule,
      imports: [
        ClientsModule.register([
          {
            name: clientToken,
            // Cast to any to support both NestJS 10 and 11 ClientProxy types
            customClass: options.clientProxyClass as any,
          },
        ]),
      ],
      providers: [
        // Provide a configured RPC client proxy with automatic type transformations
        {
          provide: RPC,
          useFactory: (client: RpcClientProxy) =>
            createRpcClientProxy(client, {
              typeInfo: options.typeInfo,
              functionInfo: options.functionInfo,
            }),
          inject: [clientToken],
        },
      ],
      exports: [ClientsModule, RPC],
      global: true,
    };
  }
}
