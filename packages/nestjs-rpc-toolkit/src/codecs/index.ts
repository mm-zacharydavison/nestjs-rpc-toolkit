/**
 * RPC Codec System
 *
 * Codecs handle serialization/deserialization of types that aren't natively JSON-serializable.
 * Built-in codecs handle Date. Users can register custom codecs for their own types.
 *
 * @example
 * ```typescript
 * // Built-in Date codec is auto-registered
 * const registry = new RpcCodecRegistry();
 *
 * // Add custom codec
 * registry.register({
 *   name: 'BigInt',
 *   canEncode: (value): value is bigint => typeof value === 'bigint',
 *   encode: (value) => value.toString(),
 *   decode: (value) => BigInt(value),
 * });
 * ```
 */

/**
 * A codec transforms values between runtime types and wire-safe formats.
 *
 * @typeParam T - The runtime type (e.g., Date, BigInt)
 * @typeParam W - The wire type (e.g., string)
 */
export interface RpcCodec<T = unknown, W = unknown> {
  /** Unique name for this codec, used in metadata (e.g., 'Date', 'BigInt') */
  name: string;

  /**
   * Check if this codec can encode a value.
   * Used for runtime detection during encoding.
   */
  canEncode(value: unknown): value is T;

  /**
   * Encode a value for wire transport.
   * @param value - The runtime value to encode
   * @returns The wire-safe representation
   */
  encode(value: T): W;

  /**
   * Decode a value from wire format.
   * @param value - The wire value to decode
   * @returns The runtime value
   */
  decode(value: W): T;
}

/**
 * Metadata that maps type fields to their codec names.
 * Generated by the RPC type generator.
 *
 * @example
 * ```typescript
 * const RpcCodecFields = {
 *   User: { createdAt: 'Date', updatedAt: 'Date' },
 *   Transaction: { amount: 'BigInt' },
 * };
 * ```
 */
export type RpcCodecMetadata = Record<string, Record<string, string>>;

/**
 * Built-in Date codec.
 * Transforms Date <-> ISO 8601 string.
 */
export const dateCodec: RpcCodec<Date, string> = {
  name: 'Date',
  canEncode: (value): value is Date => value instanceof Date,
  encode: (value) => value.toISOString(),
  decode: (value) => new Date(value),
};

/**
 * Registry for RPC codecs.
 * Handles encoding/decoding using registered codecs.
 */
export class RpcCodecRegistry {
  private codecs: Map<string, RpcCodec> = new Map();

  constructor(codecs: RpcCodec[] = [dateCodec]) {
    codecs.forEach((codec) => this.register(codec));
  }

  /**
   * Register a codec.
   * @param codec - The codec to register
   */
  register(codec: RpcCodec): void {
    this.codecs.set(codec.name, codec);
  }

  /**
   * Get a codec by name.
   * @param name - The codec name
   */
  get(name: string): RpcCodec | undefined {
    return this.codecs.get(name);
  }

  /**
   * Recursively encode a value, transforming any codec-handled types.
   * Uses runtime detection (canEncode) to find matching codecs.
   *
   * @param value - The value to encode
   * @returns The encoded value safe for wire transport
   */
  encode<T>(value: T): T {
    if (value === null || value === undefined) {
      return value;
    }

    // Check if any codec can encode this value
    for (const codec of this.codecs.values()) {
      if (codec.canEncode(value)) {
        return codec.encode(value) as unknown as T;
      }
    }

    // Not a primitive, recurse into objects/arrays
    if (typeof value !== 'object') {
      return value;
    }

    if (Array.isArray(value)) {
      return value.map((item) => this.encode(item)) as unknown as T;
    }

    const result: Record<string, unknown> = {};
    for (const key of Object.keys(value)) {
      result[key] = this.encode((value as Record<string, unknown>)[key]);
    }
    return result as T;
  }

  /**
   * Recursively decode a value, transforming fields based on metadata.
   * Uses metadata to know which fields to decode with which codec.
   *
   * Metadata format:
   * - `{ field: 'Date' }` - field uses the Date codec
   * - `{ field: '@TypeName' }` - field is a nested type with codec fields (@ prefix)
   *
   * @param value - The wire value to decode
   * @param metadata - Maps type names to field codec mappings
   * @param typeName - The type name to look up in metadata
   * @returns The decoded value with runtime types restored
   */
  decode<T>(value: T, metadata: RpcCodecMetadata, typeName?: string): T {
    if (value === null || value === undefined) {
      return value;
    }

    if (typeof value !== 'object') {
      return value;
    }

    if (Array.isArray(value)) {
      return value.map((item) => this.decode(item, metadata, typeName)) as unknown as T;
    }

    // Get field mappings for this type
    const fieldMappings = typeName ? metadata[typeName] : undefined;

    const result: Record<string, unknown> = {};
    for (const key of Object.keys(value)) {
      const val = (value as Record<string, unknown>)[key];
      const codecName = fieldMappings?.[key];

      if (codecName && val !== null && val !== undefined) {
        // Check if this is a nested type reference (prefixed with @)
        if (codecName.startsWith('@')) {
          const nestedTypeName = codecName.slice(1);
          result[key] = this.decode(val, metadata, nestedTypeName);
        } else {
          // This field should be decoded with a specific codec
          const codec = this.codecs.get(codecName);
          if (codec) {
            result[key] = codec.decode(val);
          } else {
            console.warn(`RPC Codec '${codecName}' not found for field '${key}'`);
            result[key] = val;
          }
        }
      } else if (typeof val === 'object' && val !== null) {
        // Recurse into nested objects without specific type info
        result[key] = this.decode(val, metadata, undefined);
      } else {
        result[key] = val;
      }
    }
    return result as T;
  }
}

