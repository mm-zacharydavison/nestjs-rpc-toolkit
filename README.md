# NestJS RPC Toolkit

A type-safe RPC toolkit for NestJS monorepos that enables seamless communication between microservices with automatic type generation and compile-time validation.

# Foreword
ü§ñ This README is generated by AI. I'll rewrite it later in a more human-friendly way.

## üöÄ Features

- **Type-Safe RPC Calls**: Automatically generates TypeScript client interfaces from decorated methods
- **Zero Configuration**: Simple decorators automatically create RPC patterns and type definitions
- **Modular Monolith Support**: In-process transport for high-performance monolith architectures
- **Microservice Ready**: Easy migration path from monolith to distributed microservices
- **Compile-Time Validation**: Ensures all RPC parameters and return types are JSON-serializable
- **Auto-Pattern Generation**: Creates predictable RPC patterns like `user.create`, `auth.login`

## üì¶ Installation

```bash
npm install @zdavison/nestjs-rpc-toolkit
# or
pnpm add @zdavison/nestjs-rpc-toolkit
```

## üèóÔ∏è Project Structure

This monorepo demonstrates a complete RPC system with:

```
‚îú‚îÄ‚îÄ packages/nestjs-rpc-toolkit/          # Core RPC toolkit library
‚îú‚îÄ‚îÄ examples/
‚îÇ   ‚îú‚îÄ‚îÄ lib-rpc/                          # Auto-generated type definitions
‚îÇ   ‚îú‚îÄ‚îÄ apps/api/                         # Main API application
‚îÇ   ‚îî‚îÄ‚îÄ modules/                          # Microservice modules
‚îÇ       ‚îú‚îÄ‚îÄ auth-module/                  # Authentication service
‚îÇ       ‚îî‚îÄ‚îÄ user-module/                  # User management service
```

## üõ†Ô∏è Quick Start

### 1. Create an RPC Service

Use `@RpcController()` and `@RpcMethod()` decorators to expose methods as RPC endpoints:

```typescript
// user-module/src/user.service.ts
import { Injectable, Inject } from '@nestjs/common';
import { RpcController, RpcMethod } from '@zdavison/nestjs-rpc-toolkit';
import { IRpcClient } from '@meetsmore/lib-rpc';

@Injectable()
@RpcController() // Infers 'user' from UserService class name
export class UserService {
  constructor(@Inject('RPC') private rpc: IRpcClient) {}

  @RpcMethod() // Creates pattern: 'user.create'
  async create(createUserDto: CreateUserDto): Promise<User> {
    const user = await this.createUser(createUserDto);

    // Type-safe RPC call to auth service
    await this.rpc.auth.register({
      registerDto: {
        email: createUserDto.email,
        password: 'generated-password'
      }
    });

    return user;
  }
}
```

### 2. Create Another RPC Service

```typescript
// auth-module/src/auth.service.ts
import { Injectable } from '@nestjs/common';
import { RpcController, RpcMethod } from '@zdavison/nestjs-rpc-toolkit';

@Injectable()
@RpcController() // Infers 'auth' from AuthService class name
export class AuthService {
  @RpcMethod() // Creates pattern: 'auth.register'
  async register(registerDto: RegisterDto) {
    // Registration logic
    return {
      accessToken: 'jwt-token',
      user: { id: '123', email: registerDto.email }
    };
  }
}
```

### 3. Generate Types

Configure which modules to scan for RPC methods:

```json
// examples/lib-rpc/nestjs-rpc-toolkit.config.json
{
  "packages": [
    "examples/modules/user-module",
    "examples/modules/auth-module"
  ],
  "outputDir": "examples/lib-rpc/src"
}
```

Generate type-safe client interfaces:

```bash
pnpm generate-rpc
```

This creates:

```typescript
// lib-rpc/src/all.rpc.gen.ts
export interface IRpcClient {
  user: UserDomain;
  auth: AuthDomain;
}

export interface UserDomain {
  create(params: { createUserDto: CreateUserDto }): Promise<User>;
}

export interface AuthDomain {
  register(params: { registerDto: RegisterDto }): Promise<{
    accessToken: string;
    user: { id: string; email: string; };
  }>;
}
```

### 4. Setup the Main Application

```typescript
// apps/api/src/app.module.ts
import { Module } from '@nestjs/common';
import { ClientsModule } from '@nestjs/microservices';
import { InProcessClientProxy } from '@zdavison/nestjs-rpc-toolkit';
import { AuthModule } from '@modules/auth';
import { UserModule } from '@modules/user';

@Module({
  imports: [
    ClientsModule.register([
      {
        name: 'MICROSERVICE_CLIENT',
        customClass: InProcessClientProxy,
      },
    ]),
    AuthModule,
    UserModule,
  ],
})
export class AppModule {}
```

```typescript
// apps/api/src/main.ts
import { NestFactory } from '@nestjs/core';
import { MicroserviceOptions } from '@nestjs/microservices';
import { InProcessTransportStrategy } from '@zdavison/nestjs-rpc-toolkit';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Setup in-process RPC transport
  app.connectMicroservice<MicroserviceOptions>({
    strategy: InProcessTransportStrategy.getInstance(),
  });

  await app.startAllMicroservices();
  await app.listen(3001);
}

bootstrap();
```

### 5. Use Type-Safe RPC Client

```typescript
// Any service can now make type-safe RPC calls
constructor(@Inject('RPC') private rpc: IRpcClient) {}

async someMethod() {
  // ‚úÖ Full TypeScript support and validation
  const authResult = await this.rpc.auth.register({
    registerDto: {
      email: 'user@example.com',
      password: 'secure-password'
    }
  });

  // ‚úÖ Return types are fully typed
  console.log(authResult.accessToken); // string
  console.log(authResult.user.email);  // string
}
```

## üîß Development Commands

### Root Level (Monorepo)
```bash
pnpm build               # Build all packages
pnpm dev                 # Start API in development mode
pnpm clean               # Clean all build outputs
pnpm generate-rpc        # Generate RPC types from modules
```

### Individual Packages
```bash
# Main API Application
cd examples/apps/api
pnpm start:dev           # Start with hot reload
pnpm test:e2e           # Run end-to-end tests

# Modules (auth-module, user-module)
cd examples/modules/user-module
pnpm build              # Compile TypeScript
pnpm dev                # Watch mode
pnpm start:microservice # Run standalone

# Generated Types Library
cd examples/lib-rpc
pnpm generate:types     # Generate types
pnpm build              # Build library
```

## üèõÔ∏è Architecture

### Pattern Generation
- `@RpcController()` on `UserService` ‚Üí module: `user`
- `@RpcController('custom')` ‚Üí module: `custom`
- `@RpcMethod()` on `create()` ‚Üí pattern: `user.create`

### Type Safety
The toolkit ensures compile-time validation of RPC method signatures:
- ‚úÖ **Serializable**: `string`, `number`, `boolean`, `Date`, plain objects, arrays
- ‚ùå **Not Serializable**: `Function`, `Buffer`, `Map`, `Set`, DOM elements

### Transport Strategies
- **In-Process**: High-performance in-memory communication for monoliths
- **TCP**: Ready for microservice distribution (future enhancement)
- **Redis**: Pub/sub communication (future enhancement)

## üìù Examples in This Repo

### User Service RPC Call
See `examples/modules/user-module/src/user.service.ts:31-36` for a practical example of making a type-safe RPC call from the user service to the auth service.

### Generated Client Usage
The generated `IRpcClient` interface provides full IntelliSense support:

```typescript
// Type-safe method calls
await rpc.user.create({ createUserDto: userData });
await rpc.auth.register({ registerDto: authData });

// Compile-time error for invalid parameters
await rpc.user.create({ invalidParam: 'error' }); // ‚ùå TypeScript error
```

### Module Structure
Each module follows a consistent pattern:
- `src/[module].service.ts` - RPC service with `@RpcController()` and `@RpcMethod()`
- `src/[module].controller.ts` - Optional HTTP endpoints
- `src/dto/` - Data transfer objects (auto-typed in generated client)
- `src/entities/` - Domain entities

## üöÄ Migration Path

1. **Start**: Modular monolith with in-process RPC
2. **Scale**: Extract high-load modules to separate processes
3. **Distribute**: Full microservices with TCP/Redis transport
4. **Optimize**: Service mesh integration

## üìñ API Reference

### Core Decorators

#### `@RpcController(prefix?: string)`
Marks a service class as an RPC controller.
- **prefix**: Optional module name (defaults to inferred from class name)
- **Inference**: `UserService` ‚Üí `user`, `ProductService` ‚Üí `product`

#### `@RpcMethod()`
Exposes a method as an RPC endpoint.
- **Pattern**: `{module}.{methodName}`
- **Validation**: Ensures serializable parameters and return types

### Generated Types

#### `IRpcClient`
Main client interface with domain-scoped methods.

#### Domain Interfaces
Each module gets its own domain interface (e.g., `UserDomain`, `AuthDomain`).

## ü§ù Contributing

1. Fork the repository
2. Create a feature branch
3. Add tests for new functionality
4. Update documentation
5. Submit a pull request

## üìÑ License

MIT License - see LICENSE file for details.

---

**Ready to build type-safe, scalable NestJS applications?** Start with the examples in this repo and extend them for your use case!